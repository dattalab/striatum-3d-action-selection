function get_cable_mask(OBJ)
% Uses the model generated by kinect_track to generate a binary mask where 1 indicates
% mouse and 0 occluding objects.  Useful for downstream analysis.

OBJ.update_status;

if ~OBJ.has_cable
    fprintf('No cable for this object.\n');
    return;
end

if OBJ.status.get_cable_mask
    fprintf('Get cable mask already complete.\n');
    return;
end

if ~OBJ.status.track | ~OBJ.status.track_stats
    fprintf('Object not ready for cable mask.\n');
    return;
end

opts = mergestruct(OBJ.options.common, OBJ.options.cable_mask);
opts_cell = map_parameters(opts);

% collect the movie

depth_memmap = matfile(OBJ.files.bound{1});
model_memmap = matfile(OBJ.files.track{1});

[height, width, nframes] = size(depth_memmap, opts.mem_var);
save_memmap = depth_memmap;

save_memmap.Properties.Writable = true;
save_memmap.frames_cleaned = false;
save_memmap = matfile_init_var(save_memmap, 'single', 'depth_bounded_cable_mask', [opts.box_size nframes]);

% steps

steps = 0:OBJ.frame_stride:nframes;
steps = unique([steps nframes]);

timer_upd = kinect_extract.proc_timer(length(steps) - 1);

for i = 1:length(steps) - 1

    timer_upd(i);

    left_edge = steps(i);
    right_edge = steps(i + 1);

    proc_frames = depth_memmap.(opts.mem_var)(:, :, left_edge + 1:right_edge);
    proc_mu = model_memmap.(opts.mu_var)(:, left_edge + 1:right_edge);
    proc_sig = model_memmap.(opts.sig_var)(:, :, left_edge + 1:right_edge);

    % take the mouse with the loose crop and now recompute the stats and clean everything
    % up

    proc_mask = em_cable_mask( ...
        proc_frames, proc_mu, proc_sig, 'suppress_output', true, opts_cell{:});
    save_memmap.depth_bounded_cable_mask(:, :, left_edge + 1:right_edge) = proc_mask;

end

save_memmap.frames_cleaned = true;
save_memmap.Properties.Writable = false;

clear proc_frames;
clear depth_memmap;

OBJ.update_status;
